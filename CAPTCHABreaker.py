# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-IwxsBCPbYpR3G99k-G_9XdY-pwflZmm

#CAPTCHA Breaker

## Imports
"""

import zipfile
import numpy as np
import matplotlib.pyplot as plt
import os
import keras
import tensorflow as tf
from keras.models import Model,Sequential
from keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Dropout

"""##Data Utilities"""

class DataUtils():
    def __init__(self, path:str, file_name: str):
        #set path of data
        self.path = path
        #name of zipped data file
        self.file_name = file_name
        
    def data_extraction(self, file_name: str) -> np.ndarray:
        """ 
        load and unzip data and lables
        
        :param file_name: name of dataset file
        :return letters: extracted letters from CAPTCHAs
        :return lables: extracted lables for letters 
        """

        #unzip data
        with zipfile.ZipFile(file_name) as zip_ref:
            zip_ref.extractall("samples")

        #set of lables
        lables = []
        #set of extracted letters from CAPTCHAs
        letters = []
        #set lables and split each CAPTCHA to 5 letters
        for img in os.listdir(self.path):
            #get lables from name of files
            lables.extend(list(os.path.splitext(img)[0]))
            #load images
            pic = tf.keras.preprocessing.image.load_img(os.path.join(self.path,img))
            pix = np.array(pic)
            #exract letters and resize them to be the same size
            #(it's better to do this using finding contours methods that are available in openCV library)  
            letters.extend([tf.image.resize(pix[:,25:52], [50, 50]).numpy(),
                            tf.image.resize(pix[:,52:71], [50, 50]).numpy(),
                            tf.image.resize(pix[:,71:89], [50, 50]).numpy(),
                            tf.image.resize(pix[:,89:111], [50, 50]).numpy(),
                            tf.image.resize(pix[:,111:130], [50, 50]).numpy()])

        #convert data and lables to numplables array
        letters = np.array(letters)
        lables = np.array(lables)

        return letters, lables


    def data_preprocessor(self, input_data: np.ndarray, lables: np.ndarray) -> np.ndarray:
        """
        normalize input data and encode lables
        
        :param input_data: set of extracted letters
        :param lables: set of lables
        :return:  
        """
        #normalize input data
        normalized_input_data = np.divide(input_data, 255)
        
        #encode lables
        encoded_lables = self.one_hot_encoder(lables, utils.number_of_letters)

        return normalized_input_data, encoded_lables

    def one_hot_encoder(self, array: np.ndarray, categories_number: int) -> np.ndarray:
        """
        encode data using one-hot encoding method
        
        :param array: data we want to encode
        :param categories_number: number of data categories
        :return: encoded data
        """

        #get inverse of array
        unique, inverse = np.unique(array, return_inverse=True)
        
        #encode array
        onehot = np.eye(categories_number)[inverse]
        
        return onehot



    def split_data(self, input_data: np.ndarray, target_data: np.ndarray) -> np.ndarray:
        """
        split data to train data and test data

        :param input_data: input data
        :param target_data: target data
        :return: test and train data
        """
        #calculate amount of train data (90% of whole data)
        nb_captchas = input_data.shape[0]/utils.captcha_length
        train_per = int(0.9*nb_captchas*utils.captcha_length)

        #split data to train data and test data
        x_train = input_data[:train_per]
        y_train = target_data[:train_per]

        x_test = input_data[train_per:]
        y_test = target_data[train_per:]

        return x_train, y_train, x_test, y_test


    def prepare_data(self) -> np.ndarray:
        """
        call required functions for preparing data for train

        :return: x_train, y_train, x_test and y_test
        """
        #unzip data and extract lables and letters
        X, Y = self.data_extraction(self.file_name)
        #normalize input data and encode target data
        X, Y = self.data_preprocessor(X, Y)
        #split data and return test data and train data
        return self.split_data(X, Y)

"""##Neural Network Model Handler"""

class ModelHandler():
    def __init__(self):
        #create model
        self.model = self.create_model()
        #history of model
        self.history = None

    def create_model(self) -> keras.engine.sequential.Sequential:
        """
        create neural network model
        
        :return: NNmodel
        """
        #define model as sequential
        model = Sequential()

        # First convolutional layer with max pooling
        model.add(Conv2D(20, (5, 5), padding="same", input_shape= (50,50,3), activation="relu"))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

        #Dropout layer
        model.add(Dropout(0.1))
        
        # Second convolutional layer with max pooling
        model.add(Conv2D(50, (5, 5), padding="same", activation="relu"))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

        # Hidden layer with 64 nodes
        model.add(Flatten())
        model.add(Dense(64, activation="relu"))

        # Output layer with 37 nodes (one for each possible letter/number we predict)
        model.add(Dense(utils.number_of_letters, activation="softmax"))

        #compile model
        model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

        return model

    def plot_history(self):
        #plot loss in train process
        plt.figure(0)
        plt.plot(self.history.history['loss'])
        plt.title('Loss in Train Process')
        plt.ylabel('loss')
        plt.xlabel('epoch')
        plt.savefig('history_loss.jpg')

        #plot accuracy in train process
        plt.figure(1)
        plt.plot(self.history.history['accuracy'])
        plt.title('Accuracy in Train Process')
        plt.ylabel('accuracy')
        plt.xlabel('epoch')
        plt.savefig('history_accuracy.jpg')

    def train_model(self, x_train: np.ndarray, y_train: np.ndarray, batch_size: int = 128, epoch: int = 10):
        """
        train model
        """
        # train model
        self.history = self.model.fit(x_train, y_train, batch_size=batch_size, epochs=epoch)
        # save model
        self.model.save('CAPTCHABreaker.h5')

    def predict(self, x_test: np.ndarray, y_test: np.ndarray) -> np.ndarray:
        """
        predict the sequence of input CAPTCHA images 

        :param x_test: input data to predict
        :param y_test: true output of input data
        :return y_pred: decoded predicted values
        :return y_true: decoded true output values
        """
        #predict test data
        y_pred = self.model.predict(x_test)
        
        #decode predicted targets and true targets
        y_pred = np.argmax(y_pred, axis=1)
        y_true = np.argmax(y_test, axis=1)

        #locate each CAPTCHA's letters in a row of numpy array(for calculatig accuracy)
        y_pred = y_pred.reshape(int(y_pred.shape[0]/utils.captcha_length),utils.captcha_length)
        y_true = y_true.reshape(int(y_true.shape[0]/utils.captcha_length),utils.captcha_length)

        return y_pred, y_true

"""##Utilities"""

class Utils():
    def __init__(self, number_of_letters: int = 37, captcha_length: int = 5):
        #nember of letters that are used in CAPTCHAs
        self.number_of_letters = number_of_letters
        #each CAPTCHA's length
        self.captcha_length = captcha_length

    def get_accuracy(self, y_true: np.ndarray, y_pred: np.ndarray) -> float:
        """
        calculate accuracy of predicted datas

        :param y_true: decoded true output values
        :param y_pred: decoded predicted values
        :return: accuracy percentage
        """
        #number of CAPTCHAs that are redicted correctly
        trues = 0
        #set of CAPTCHAs that are not predicted correctly
        falses = []
        #check if CAPTCHA is correctly predicted for each CAPTCHA of test data
        for i in range(y_pred.shape[0]):
            if y_pred[i].all() == y_true[i].all():
                trues+=1
            else:
                falses.append(i)
        #return accuracy
        return (trues/y_pred.shape[0])*100

"""## Main Class"""

class MainClass():
    def __init__(self, data_path: str, zipped_data_file_name: str):
        #instansiation 
        self.data_handler = DataUtils(data_path, zipped_data_file_name)
        self.model_handler = ModelHandler()

        #datas
        self.x_train = None
        self.y_train = None
        self.x_test = None
        self.y_test = None

    def prepare_data(self):
        #preparing data for train
        self.x_train, self.y_train, self.x_test, self.y_test = self.data_handler.prepare_data()  

    def train_model(self):
        #train model
        self.model_handler.train_model(self.x_train, self.y_train)    

    def predict(self) -> np.ndarray:
        #predict output for test data
        return self.model_handler.predict(self.x_test, self.y_test)
    
    def evaluate_model(self):
        #predict out put for test data
        y_pred, y_true = self.predict()
        #plot accuracy and loss in train process
        self.model_handler.plot_history()
        
        #get accuracy
        accuracy = utils.get_accuracy(y_true,y_pred)
        #print(accuracy)
        print(f'accuracy = {accuracy}%')
        #write accuracy in text file
        with open('result.txt', 'w') as f:
            f.write(f'Accuracy of Trained Model on Test data: {accuracy}%')

    def run(self):
        #run functions of MainClass
        self.prepare_data()
        self.train_model()
        self.evaluate_model()

"""##Run"""

#create instance of Utils
utils = Utils()
#create instance of MainClass 
main_class = MainClass('/content/samples','samples.zip')
#run necessary functions
main_class.run()